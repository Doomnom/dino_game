<!DOCTYPE html>
<html>
<head>
    <title>Dino Runner Game</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
            max-width: 100vw;
            max-height: 100vh;
        }
        #gameOver {
            display: none;
            text-align: center;
            font-family: Arial, sans-serif;
            font-size: 24px;
            margin-top: 20px;
            color: black;
        }
        #scorePanel {
            text-align: center;
            font-family: Arial, sans-serif;
            margin-top: 10px;
        }
        #submitScore {
            display: none;
            text-align: center;
            margin-top: 20px;
        }
        #leaderboard {
            text-align: center;
            font-family: Arial, sans-serif;
            margin-top: 20px;
        }
        #errorMessage {
            color: red;
            display: none;
            text-align: center;
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOver">Game Over! Press Space or Tap to Restart</div>
    <div id="scorePanel">
        High Score: <span id="highScore">0</span><br>
        Score: <span id="score">0</span>
    </div>
    <div id="submitScore">
        Enter your name: <input type="text" id="playerName" maxlength="20">
        <button id="submitScoreButton">Submit Score</button>
    </div>
    <div id="errorMessage"></div>
    <div id="leaderboard">
        <h3>Global Top 5 High Scores</h3>
        <ul id="highScoresList"></ul>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Firebase config (replace with actual values for testing)
            const firebaseConfig = {
                aapiKey: "AIzaSyAJCkPYWK3mDTsbEw_VDgh30PbY7Z3BhFg",
                authDomain: "dinogame-r3dnax.firebaseapp.com",
                databaseURL: "https://dinogame-r3dnax-default-rtdb.europe-west1.firebasedatabase.app",
                projectId: "dinogame-r3dnax",
                storageBucket: "dinogame-r3dnax.firebasestorage.app",
                messagingSenderId: "401593443465",
                appId: "1:401593443465:web:492e13e480e0488d3d1258",
                measurementId: "G-JS0KZL2BT5"
            };
            firebase.initializeApp(firebaseConfig);

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            // Dynamic canvas sizing
            canvas.width = Math.min(800, window.innerWidth * 0.9);
            canvas.height = Math.min(400, window.innerHeight * 0.5);
            const gameOverDiv = document.getElementById('gameOver');
            const scoreDisplay = document.getElementById('score');
            const highScoreDisplay = document.getElementById('highScore');
            const submitScoreDiv = document.getElementById('submitScore');
            const playerNameInput = document.getElementById('playerName');
            const submitScoreButton = document.getElementById('submitScoreButton');
            const errorMessage = document.getElementById('errorMessage');
            const leaderboardDiv = document.getElementById('leaderboard');
            const highScoresList = document.getElementById('highScoresList');

            // Game objects (encapsulated in state)
            const gameState = {
                dino: {
                    x: 50,
                    y: 340 - 60,
                    width: 40,
                    height: 60,
                    vy: 0,
                    gravity: 0.8,
                    jumpPower: -15,
                    isJumping: false,
                    isDucking: false
                },
                obstacles: [],
                score: 0,
                highScore: 0,
                speed: 5,
                gameOver: false,
                gameStarted: false,
                frameCount: 0,
                useFallbackShapes: false,
                imagesLoaded: 0,
                totalImages: 0,
                loadTimeout: 5000,
                images: {
                    dino_run: [new Image(), new Image(), new Image()],
                    dino_jump: new Image(),
                    dino_duck: new Image(),
                    tentacle: [new Image(), new Image()],
                    sawblade: [new Image(), new Image(), new Image()],
                    drone: [new Image(), new Image()]
                },
                imageData: {
                    dino_run: [],
                    dino_jump: null,
                    dino_duck: null,
                    tentacle: [],
                    sawblade: [],
                    drone: []
                },
                imageDataReady: false
            };

            // Image sources
            gameState.images.dino_run[0].src = 'https://doomnom.github.io/dino_game/sprites/dino_run1.png';
            gameState.images.dino_run[1].src = 'https://doomnom.github.io/dino_game/sprites/dino_run2.png';
            gameState.images.dino_run[2].src = 'https://doomnom.github.io/dino_game/sprites/dino_run3.png';
            gameState.images.dino_jump.src = 'https://doomnom.github.io/dino_game/sprites/dino_jump.png';
            gameState.images.dino_duck.src = 'https://doomnom.github.io/dino_game/sprites/dino_duck.png';
            gameState.images.tentacle[0].src = 'https://doomnom.github.io/dino_game/sprites/tentacle1.png';
            gameState.images.tentacle[1].src = 'https://doomnom.github.io/dino_game/sprites/tentacle2.png';
            gameState.images.sawblade[0].src = 'https://doomnom.github.io/dino_game/sprites/sawblade1.png';
            gameState.images.sawblade[1].src = 'https://doomnom.github.io/dino_game/sprites/sawblade2.png';
            gameState.images.sawblade[2].src = 'https://doomnom.github.io/dino_game/sprites/sawblade3.png';
            gameState.images.drone[0].src = 'https://doomnom.github.io/dino_game/sprites/drone1.png';
            gameState.images.drone[1].src = 'https://doomnom.github.io/dino_game/sprites/drone2.png';

            // Image loading
            for (let key in gameState.images) {
                if (Array.isArray(gameState.images[key])) {
                    gameState.totalImages += gameState.images[key].length;
                    gameState.images[key].forEach(img => {
                        img.onload = () => gameState.imagesLoaded++;
                        img.onerror = () => {
                            gameState.imagesLoaded++;
                            gameState.useFallbackShapes = true;
                        };
                    });
                } else {
                    gameState.totalImages++;
                    gameState.images[key].onload = () => gameState.imagesLoaded++;
                    gameState.images[key].onerror = () => {
                        gameState.imagesLoaded++;
                        gameState.useFallbackShapes = true;
                    };
                }
            }

            setTimeout(() => {
                if (gameState.imagesLoaded < gameState.totalImages) {
                    gameState.useFallbackShapes = true;
                    gameState.imagesLoaded = gameState.totalImages;
                }
            }, gameState.loadTimeout);

            // Create image data for pixel-perfect collision
            function createImageData() {
                if (gameState.useFallbackShapes) return;
                // Dino run
                gameState.imageData.dino_run = gameState.images.dino_run.map(img => {
                    const offscreen = document.createElement('canvas');
                    offscreen.width = gameState.dino.width;
                    offscreen.height = gameState.dino.height;
                    const ctx = offscreen.getContext('2d');
                    ctx.drawImage(img, 0, 0, offscreen.width, offscreen.height);
                    return ctx.getImageData(0, 0, offscreen.width, offscreen.height);
                });
                // Dino jump
                const offscreenJump = document.createElement('canvas');
                offscreenJump.width = gameState.dino.width;
                offscreenJump.height = gameState.dino.height;
                const ctxJump = offscreenJump.getContext('2d');
                ctxJump.drawImage(gameState.images.dino_jump, 0, 0, offscreenJump.width, offscreenJump.height);
                gameState.imageData.dino_jump = ctxJump.getImageData(0, 0, offscreenJump.width, offscreenJump.height);
                // Dino duck
                const offscreenDuck = document.createElement('canvas');
                offscreenDuck.width = gameState.dino.width;
                offscreenDuck.height = gameState.dino.height / 2;
                const ctxDuck = offscreenDuck.getContext('2d');
                ctxDuck.drawImage(gameState.images.dino_duck, 0, 0, offscreenDuck.width, offscreenDuck.height);
                gameState.imageData.dino_duck = ctxDuck.getImageData(0, 0, offscreenDuck.width, offscreenDuck.height);
                // Tentacles
                gameState.imageData.tentacle = gameState.images.tentacle.map(img => {
                    const offscreen = document.createElement('canvas');
                    offscreen.width = 20;
                    offscreen.height = 40;
                    const ctx = offscreen.getContext('2d');
                    ctx.drawImage(img, 0, 0, offscreen.width, offscreen.height);
                    return ctx.getImageData(0, 0, offscreen.width, offscreen.height);
                });
                // Sawblades
                gameState.imageData.sawblade = gameState.images.sawblade.map(img => {
                    const offscreen = document.createElement('canvas');
                    offscreen.width = 30;
                    offscreen.height = 30;
                    const ctx = offscreen.getContext('2d');
                    ctx.drawImage(img, 0, 0, offscreen.width, offscreen.height);
                    return ctx.getImageData(0, 0, offscreen.width, offscreen.height);
                });
                // Drones
                gameState.imageData.drone = gameState.images.drone.map(img => {
                    const offscreen = document.createElement('canvas');
                    offscreen.width = 30;
                    offscreen.height = 30;
                    const ctx = offscreen.getContext('2d');
                    ctx.drawImage(img, 0, 0, offscreen.width, offscreen.height);
                    return ctx.getImageData(0, 0, offscreen.width, offscreen.height);
                });
            }

            // Drawing functions
            function drawDino(timestamp) {
                if (gameState.useFallbackShapes) {
                    ctx.fillStyle = 'blue';
                    if (gameState.dino.isDucking) {
                        ctx.fillRect(gameState.dino.x, gameState.dino.y + 20, gameState.dino.width, gameState.dino.height / 2);
                    } else {
                        ctx.fillRect(gameState.dino.x, gameState.dino.y, gameState.dino.width, gameState.dino.height);
                    }
                } else {
                    if (gameState.dino.isDucking) {
                        ctx.drawImage(gameState.images.dino_duck, gameState.dino.x, gameState.dino.y + 20, gameState.dino.width, gameState.dino.height / 2);
                    } else if (gameState.dino.isJumping) {
                        ctx.drawImage(gameState.images.dino_jump, gameState.dino.x, gameState.dino.y, gameState.dino.width, gameState.dino.height);
                    } else {
                        const animationSpeed = 100; // ms per frame
                        const frameIndex = Math.floor((timestamp / animationSpeed) % gameState.images.dino_run.length);
                        ctx.drawImage(gameState.images.dino_run[frameIndex], gameState.dino.x, gameState.dino.y, gameState.dino.width, gameState.dino.height);
                    }
                }
            }

            function drawObstacle(obstacle, timestamp) {
                if (gameState.useFallbackShapes) {
                    if (obstacle.type === 'tentacle') {
                        ctx.fillStyle = 'purple';
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    } else if (obstacle.type === 'sawblade') {
                        ctx.fillStyle = 'silver';
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2, obstacle.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (obstacle.type === 'drone') {
                        ctx.fillStyle = 'red';
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + obstacle.height);
                        ctx.lineTo(obstacle.x + obstacle.width / 2, obstacle.y);
                        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else {
                    const animationSpeed = 100; // ms per frame
                    let frames;
                    if (obstacle.type === 'tentacle') {
                        frames = gameState.images.tentacle;
                    } else if (obstacle.type === 'sawblade') {
                        frames = gameState.images.sawblade;
                    } else if (obstacle.type === 'drone') {
                        frames = gameState.images.drone;
                    }
                    const frameIndex = Math.floor((timestamp / animationSpeed) % frames.length);
                    ctx.drawImage(frames[frameIndex], obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                }
            }

            function drawGround() {
                ctx.fillStyle = 'gray';
                ctx.fillRect(0, 340, canvas.width, 10);
            }

            // Game logic
            function spawnObstacle() {
                if (gameState.frameCount % (60 + Math.floor(Math.random() * 60)) === 0) {
                    let type, yPos;
                    const rand = Math.random();
                    type = rand < 0.33 ? 'tentacle' : rand < 0.66 ? 'sawblade' : 'drone';
                    if (type === 'tentacle') {
                        yPos = 300;
                    } else if (type === 'sawblade') {
                        yPos = 200;
                    } else {
                        yPos = Math.random() < 0.5 ? 280 : 200;
                    }
                    let obstacle = {
                        x: canvas.width,
                        y: yPos,
                        width: type === 'tentacle' ? 20 : 30,
                        height: type === 'tentacle' ? 40 : 30,
                        type: type
                    };
                    gameState.obstacles.push(obstacle);
                }
            }

            function updateObstacles() {
                for (let i = gameState.obstacles.length - 1; i >= 0; i--) {
                    gameState.obstacles[i].x -= gameState.speed;
                    if (gameState.obstacles[i].x + gameState.obstacles[i].width < 0) {
                        gameState.obstacles.splice(i, 1);
                        gameState.score += 10;
                        if (gameState.score > gameState.highScore) {
                            gameState.highScore = gameState.score;
                        }
                    }
                }
            }

            function checkCollision(timestamp) {
                if (gameState.useFallbackShapes || !gameState.imageDataReady) {
                    // Bounding box collision
                    for (let obstacle of gameState.obstacles) {
                        let dinoHeight = gameState.dino.isDucking ? gameState.dino.height / 2 : gameState.dino.height;
                        let dinoY = gameState.dino.isDucking ? gameState.dino.y + 20 : gameState.dino.y;
                        if (gameState.dino.x < obstacle.x + obstacle.width &&
                            gameState.dino.x + gameState.dino.width > obstacle.x &&
                            dinoY < obstacle.y + obstacle.height &&
                            dinoY + dinoHeight > obstacle.y) {
                            return true;
                        }
                    }
                    return false;
                } else {
                    // Pixel-perfect collision
                    for (let obstacle of gameState.obstacles) {
                        let dinoTop = gameState.dino.isDucking ? gameState.dino.y + 20 : gameState.dino.y;
                        let dinoHeight = gameState.dino.isDucking ? gameState.dino.height / 2 : gameState.dino.height;
                        let dinoLeft = gameState.dino.x;
                        let dinoRight = dinoLeft + gameState.dino.width;
                        let dinoBottom = dinoTop + dinoHeight;
                        let obsLeft = obstacle.x;
                        let obsRight = obsLeft + obstacle.width;
                        let obsTop = obstacle.y;
                        let obsBottom = obsTop + obstacle.height;
                        let overlapLeft = Math.max(dinoLeft, obsLeft);
                        let overlapRight = Math.min(dinoRight, obsRight);
                        let overlapTop = Math.max(dinoTop, obsTop);
                        let overlapBottom = Math.min(dinoBottom, obsBottom);
                        if (overlapLeft < overlapRight && overlapTop < overlapBottom) {
                            // Get dino ImageData
                            let dinoData;
                            if (gameState.dino.isDucking) {
                                dinoData = gameState.imageData.dino_duck;
                            } else if (gameState.dino.isJumping) {
                                dinoData = gameState.imageData.dino_jump;
                            } else {
                                const animationSpeed = 100;
                                const frameIndex = Math.floor((timestamp / animationSpeed) % gameState.images.dino_run.length);
                                dinoData = gameState.imageData.dino_run[frameIndex];
                            }
                            // Get obstacle ImageData
                            let obsData;
                            const animationSpeed = 100;
                            let frames = gameState.imageData[obstacle.type];
                            const frameIndex = Math.floor((timestamp / animationSpeed) % frames.length);
                            obsData = frames[frameIndex];
                            // Loop through overlap area
                            for (let oy = Math.floor(overlapTop); oy < Math.ceil(overlapBottom); oy++) {
                                for (let ox = Math.floor(overlapLeft); ox < Math.ceil(overlapRight); ox++) {
                                    // Map to dino local coordinates
                                    let dx = ox - dinoLeft;
                                    let dy = oy - dinoTop;
                                    if (dx >= 0 && dx < dinoData.width && dy >= 0 && dy < dinoData.height) {
                                        let dinoIndex = (Math.floor(dy) * dinoData.width + Math.floor(dx)) * 4 + 3;
                                        let dinoAlpha = dinoData.data[dinoIndex];
                                        if (dinoAlpha > 0) {
                                            // Map to obstacle local coordinates
                                            let oxLocal = ox - obsLeft;
                                            let oyLocal = oy - obsTop;
                                            if (oxLocal >= 0 && oxLocal < obsData.width && oyLocal >= 0 && oyLocal < obsData.height) {
                                                let obsIndex = (Math.floor(oyLocal) * obsData.width + Math.floor(oxLocal)) * 4 + 3;
                                                let obsAlpha = obsData.data[obsIndex];
                                                if (obsAlpha > 0) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return false;
                }
            }

            function updateDino() {
                if (gameState.dino.isJumping) {
                    gameState.dino.vy += gameState.dino.gravity;
                    gameState.dino.y += gameState.dino.vy;
                    if (gameState.dino.isDucking) {
                        if (gameState.dino.y > 340 - gameState.dino.height / 2) {
                            gameState.dino.y = 340 - gameState.dino.height / 2;
                            gameState.dino.vy = 0;
                            gameState.dino.isJumping = false;
                        }
                    } else {
                        if (gameState.dino.y > 340 - gameState.dino.height) {
                            gameState.dino.y = 340 - gameState.dino.height;
                            gameState.dino.vy = 0;
                            gameState.dino.isJumping = false;
                        }
                    }
                }
            }

            // Input handling - Keyboard
            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space' && !gameState.gameOver && !gameState.gameStarted) {
                    gameState.gameStarted = true;
                } else if (event.code === 'Space' && !gameState.gameOver && gameState.gameStarted) {
                    if (!gameState.dino.isJumping) {
                        gameState.dino.vy = gameState.dino.jumpPower;
                        gameState.dino.isJumping = true;
                        gameState.dino.isDucking = false;
                    }
                } else if (event.code === 'ArrowDown' && !gameState.gameOver && !gameState.dino.isJumping && gameState.gameStarted) {
                    gameState.dino.isDucking = true;
                } else if (event.code === 'Space' && gameState.gameOver) {
                    resetGame();
                }
            });

            document.addEventListener('keyup', function(event) {
                if (event.code === 'ArrowDown') {
                    gameState.dino.isDucking = false;
                }
            });

            // Input handling - Touch
            document.addEventListener('touchstart', function(event) {
                if (event.target.closest('#submitScore')) {
                    return;
                }
                event.preventDefault();
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                if (touchX >= 0 && touchY >= 0 && touchX <= canvas.width && touchY <= canvas.height &&
                    touchX > canvas.width / 2 && touchY > canvas.height / 2 && !gameState.gameOver && !gameState.dino.isJumping && gameState.gameStarted) {
                    gameState.dino.isDucking = true;
                } else {
                    if (!gameState.gameOver && !gameState.gameStarted) {
                        gameState.gameStarted = true;
                    } else if (!gameState.gameOver && gameState.gameStarted && !gameState.dino.isJumping) {
                        gameState.dino.vy = gameState.dino.jumpPower;
                        gameState.dino.isJumping = true;
                        gameState.dino.isDucking = false;
                    } else if (gameState.gameOver) {
                        resetGame();
                    }
                }
            });

            document.addEventListener('touchend', function(event) {
                if (event.target.closest('#submitScore')) {
                    return;
                }
                event.preventDefault();
                gameState.dino.isDucking = false;
            });

            // Reset game state
            function resetGame() {
                gameState.obstacles = [];
                gameState.score = 0;
                gameState.speed = 5;
                gameState.gameOver = false;
                gameState.gameStarted = false;
                gameOverDiv.style.display = 'none';
                gameState.dino.y = 340 - gameState.dino.height;
                gameState.dino.vy = 0;
                gameState.dino.isJumping = false;
                gameState.dino.isDucking = false;
                submitScoreDiv.style.display = 'none';
                errorMessage.style.display = 'none';
                loadHighScores();
            }

            // Score submission
            function submitScore() {
                const name = playerNameInput.value.trim();
                if (!name) {
                    errorMessage.textContent = 'Please enter a name';
                    errorMessage.style.display = 'block';
                    return;
                }
                if (gameState.highScore > 0) {
                    const scoreEntry = { name: name, score: gameState.highScore, timestamp: Date.now() };
                    firebase.database().ref('highscores').push(scoreEntry)
                        .then(() => {
                            playerNameInput.value = '';
                            submitScoreDiv.style.display = 'none';
                            errorMessage.style.display = 'none';
                            loadHighScores();
                        })
                        .catch(error => {
                            errorMessage.textContent = 'Error submitting score: ' + error.message;
                            errorMessage.style.display = 'block';
                        });
                } else {
                    submitScoreDiv.style.display = 'none';
                }
            }

            submitScoreButton.addEventListener('click', submitScore);

            // Load high scores
            function loadHighScores() {
                firebase.database().ref('highscores').orderByChild('score').limitToLast(5)
                    .once('value')
                    .then(snapshot => {
                        highScoresList.innerHTML = '';
                        const scores = [];
                        snapshot.forEach(childSnapshot => {
                            scores.unshift(childSnapshot.val());
                        });
                        if (scores.length) {
                            scores.forEach(s => {
                                const li = document.createElement('li');
                                li.textContent = `${s.name}: ${s.score}`;
                                highScoresList.appendChild(li);
                            });
                        } else {
                            const li = document.createElement('li');
                            li.textContent = 'No high scores yet.';
                            highScoresList.appendChild(li);
                        }
                    })
                    .catch(error => {
                        console.error('Leaderboard fetch error:', error);
                        const li = document.createElement('li');
                        li.textContent = 'Error loading high scores.';
                        highScoresList.appendChild(li);
                    });
            }

           function gameLoop(timestamp) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (gameState.imagesLoaded < gameState.totalImages) {
        ctx.fillStyle = 'black';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Loading... ${Math.round((gameState.imagesLoaded / gameState.totalImages) * 100)}%`, canvas.width / 2, canvas.height / 2);
        requestAnimationFrame(gameLoop);
        return;
    }

    // Initialize image data for pixel-perfect collision if not done
    if (!gameState.imageDataReady) {
        createImageData();
        gameState.imageDataReady = true;
    }

    drawGround();
    drawDino(timestamp);

    if (!gameState.gameStarted && !gameState.gameOver) {
        ctx.fillStyle = 'black';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Press Space or Tap to Start', canvas.width / 2, canvas.height / 2);
        ctx.fillText('Hold Bottom-Right to Duck', canvas.width / 2, canvas.height / 2 + 30);
    } else if (!gameState.gameOver) {
        gameState.frameCount++;
        updateDino();
        spawnObstacle();
        updateObstacles();
        gameState.speed += 0.0005;
        if (checkCollision(timestamp)) {
            gameState.gameOver = true;
            gameOverDiv.style.display = 'block';
            submitScoreDiv.style.display = 'block';
        }
        for (let obstacle of gameState.obstacles) {
            drawObstacle(obstacle, timestamp);
        }
    }

    scoreDisplay.textContent = gameState.score;
    highScoreDisplay.textContent = gameState.highScore;

    requestAnimationFrame(gameLoop);
           }
        })